import { useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { FlashCard } from "@/components/FlashCard";
import { Controls } from "@/components/Controls";

type FlashCardData = {
  id: number;
  question: string;
  answer: string;
};

type CategoryCards = "default" | "htmlcss" | "js" | "react" | "ts";

const flashcardsDef: FlashCardData[] = [
  {
    id: 1,
    question: "Что такое React?",
    answer:
      "React — это библиотека JavaScript для создания пользовательских интерфейсов, разработанная Facebook. Она позволяет создавать компоненты, которые управляют своим состоянием и рендерятся в зависимости от этого состояния.",
  },
  {
    id: 2,
    question: "Что такое компонент в React?",
    answer:
      "Компонент в React — это независимый и переиспользуемый блок кода, который инкапсулирует логику и разметку. Компоненты могут быть функциональными или классовыми.",
  },
  {
    id: 3,
    question: "Какое отличие между функциональными и классовыми компонентами?",
    answer:
      "Функциональные компоненты — это простые функции, которые принимают props и возвращают JSX. Классовые компоненты — это классы, которые могут иметь состояние и методы жизненного цикла.",
  },
  {
    id: 4,
    question: "Что такое состояние (state) в React?",
    answer:
      "Состояние (state) — это объект, который хранит динамические данные компонента и определяет его поведение. Изменения состояния приводят к повторному рендерингу компонента.",
  },
  {
    id: 5,
    question: "Как передать данные от родительского компонента к дочернему?",
    answer:
      "Данные передаются от родительского компонента к дочернему через props. Props — это объект, содержащий все атрибуты, переданные компоненту.",
  },
  {
    id: 6,
    question: "Что такое JSX?",
    answer:
      "JSX — это расширение синтаксиса JavaScript, которое позволяет писать HTML-подобный код внутри JavaScript. Он используется в React для описания пользовательского интерфейса.",
  },
  {
    id: 7,
    question: "Как работает виртуальный DOM в React?",
    answer:
      "Виртуальный DOM — это легковесная копия реального DOM. React использует его для оптимизации обновлений, сравнивая текущую и предыдущую версии виртуального DOM и обновляя только измененные элементы в реальном DOM.",
  },
  {
    id: 8,
    question: "Что такое хуки (hooks) в React?",
    answer:
      "Хуки — это функции, которые позволяют использовать состояние и другие возможности React в функциональных компонентах. Примеры хуков: useState, useEffect, useContext.",
  },
  {
    id: 9,
    question: "Как управлять побочными эффектами в React?",
    answer:
      "Для управления побочными эффектами в React используется хук useEffect. Он позволяет выполнять побочные эффекты, такие как загрузка данных, подписки или изменения DOM, после рендеринга компонента.",
  },
  {
    id: 10,
    question: "Что такое контекст (Context) в React?",
    answer:
      "Контекст (Context) — это способ передачи данных через дерево компонентов без необходимости передавать props на каждом уровне. Он используется для глобальных данных, таких как текущий пользователь или тема.",
  },

  {
    id: 11,
    question: "Что такое Redux и как он связан с React?",
    answer:
      "Redux — это библиотека для управления состоянием приложения. Она часто используется с React для централизованного управления состоянием, что упрощает передачу данных между компонентами.",
  },
  {
    id: 12,
    question: "Как использовать useState в React?",
    answer:
      "useState — это хук, который позволяет добавлять состояние в функциональные компоненты. Вызывается с начальным значением состояния и возвращает массив с текущим значением состояния и функцией для его обновления.",
  },
  {
    id: 13,
    question: "Что такое useEffect и когда его использовать?",
    answer:
      "useEffect — это хук, который позволяет выполнять побочные эффекты в функциональных компонентах. Он используется для операций, таких как загрузка данных, подписка на события или изменение DOM.",
  },
  {
    id: 14,
    question: "Как работает useContext?",
    answer:
      "useContext — это хук, который позволяет использовать контекст в функциональных компонентах. Он принимает объект контекста и возвращает текущее значение контекста.",
  },
  {
    id: 15,
    question: "Что такое React Router?",
    answer:
      "React Router — это библиотека для маршрутизации в React-приложениях. Она позволяет создавать одностраничные приложения с навигацией без перезагрузки страницы.",
  },
  {
    id: 16,
    question: "Как оптимизировать производительность React-приложения?",
    answer:
      "Для оптимизации производительности можно использовать мемоизацию компонентов с помощью React.memo, хуки useMemo и useCallback, а также избегать ненужных рендеров и использовать динамическую загрузку компонентов.",
  },
  {
    id: 17,
    question: "Что такое PropTypes?",
    answer:
      "PropTypes — это библиотека для проверки типов props в React-компонентах. Она помогает убедиться, что компоненты получают props нужного типа и формата.",
  },
  {
    id: 18,
    question: "Как использовать фрагменты в React?",
    answer:
      "Фрагменты позволяют группировать список дочерних элементов без добавления дополнительных узлов в DOM. Используются с помощью <React.Fragment> или сокращенной записи <>.</>",
  },
  {
    id: 19,
    question: "Что такое серверный рендеринг (SSR) в React?",
    answer:
      "Серверный рендеринг (SSR) — это процесс рендеринга React-компонентов на сервере, а не в браузере. Это улучшает SEO и время загрузки страницы.",
  },
  {
    id: 20,
    question:
      "Как использовать React.lazy для динамической загрузки компонентов?",
    answer:
      "React.lazy позволяет загружать компоненты по требованию, что уменьшает размер начальной загрузки приложения. Используется вместе с Suspense для отображения запасного контента, пока компонент загружается.",
  },
  {
    id: 21,
    question: "Что такое HOC (Higher-Order Component) в React?",
    answer:
      "HOC (Higher-Order Component) — это функция, которая принимает компонент и возвращает новый компонент. Он используется для повторного использования логики между компонентами.",
  },
  {
    id: 22,
    question: "Как работает useReducer в React?",
    answer:
      "useReducer — это хук, который используется для управления сложным состоянием в функциональных компонентах. Он принимает редьюсер и начальное состояние и возвращает текущее состояние и функцию dispatch.",
  },
  {
    id: 23,
    question: "Что такое React.memo и когда его использовать?",
    answer:
      "React.memo — это HOC, который предотвращает повторный рендеринг компонента, если его props не изменились. Используется для оптимизации производительности.",
  },
  {
    id: 24,
    question: "Как использовать useRef в React?",
    answer:
      "useRef — это хук, который возвращает изменяемый ref-объект. Он используется для доступа к DOM-элементам или сохранения любого мутируемого значения, которое не вызывает повторный рендеринг при изменении.",
  },
  {
    id: 25,
    question: "Что такое Suspense в React?",
    answer:
      "Suspense — это компонент, который позволяет показывать запасной контент (например, индикатор загрузки) во время ожидания загрузки асинхронных данных или компонентов.",
  },
  {
    id: 26,
    question: "Как работает Concurrent Mode в React?",
    answer:
      "Concurrent Mode — это набор новых возможностей в React, которые помогают приложениям оставаться отзывчивыми и плавными, откладывая менее важные задачи и позволяя более важным задачам прерывать менее важные.",
  },
  {
    id: 27,
    question: "Что такое React Fiber?",
    answer:
      "React Fiber — это новая архитектура внутреннего механизма рендеринга React, которая улучшает его способность к согласованию и делает возможными такие функции, как Concurrent Mode.",
  },
  {
    id: 28,
    question: "Как использовать useCallback в React?",
    answer:
      "useCallback — это хук, который возвращает мемоизированную версию функции, которая изменяется только при изменении одной из зависимостей. Используется для оптимизации производительности.",
  },
  {
    id: 29,
    question: "Что такое Error Boundaries в React?",
    answer:
      "Error Boundaries — это компоненты, которые ловят ошибки JavaScript в любом месте их дочернего дерева компонентов, логируют их и отображают запасной UI вместо сломанного дерева компонентов.",
  },
  {
    id: 30,
    question: "Как использовать useLayoutEffect в React?",
    answer:
      "useLayoutEffect — это хук, который запускается синхронно после всех изменений DOM. Используется для операций, которые должны произойти после того, как DOM был изменен, но до того, как браузер отобразит изменения.",
  },

  {
    id: 31,
    question: "Как использовать useImperativeHandle в React?",
    answer:
      "useImperativeHandle — это хук, который позволяет настраивать значение экземпляра, которое предоставляется родительским компонентам при использовании ref. Он используется в сочетании с forwardRef.",
  },
  {
    id: 32,
    question: "Что такое React.StrictMode?",
    answer:
      "React.StrictMode — это инструмент для выявления потенциальных проблем в приложении. Он активирует дополнительные проверки и предупреждения для своих дочерних компонентов.",
  },
  {
    id: 33,
    question: "Как работает forwardRef в React?",
    answer:
      "forwardRef — это функция, которая позволяет передавать ref через компонент к одному из его дочерних компонентов. Это полезно для интеграции с DOM-элементами или сторонними библиотеками.",
  },
  {
    id: 34,
    question: "Что такое React Portals?",
    answer:
      "React Portals позволяют рендерить дочерние элементы в DOM-узел, который существует вне иерархии DOM родительского компонента. Это полезно для модальных окон и всплывающих подсказок.",
  },
  {
    id: 35,
    question: "Как использовать useTransition в React?",
    answer:
      "useTransition — это хук, который позволяет создавать переходы между состояниями, которые не блокируют пользовательский интерфейс. Он используется для создания плавных анимаций и переходов.",
  },
  {
    id: 36,
    question: "Что такое useDeferredValue в React?",
    answer:
      "useDeferredValue — это хук, который позволяет откладывать обновление значения до тех пор, пока не будет завершена более важная работа. Это помогает избежать задержек в пользовательском интерфейсе.",
  },
  {
    id: 37,
    question: "Как работает useId в React?",
    answer:
      "useId — это хук, который генерирует уникальные идентификаторы для компонентов. Это полезно для обеспечения уникальности атрибутов id в HTML, особенно при рендеринге списков.",
  },
  {
    id: 38,
    question: "Что такое React DevTools?",
    answer:
      "React DevTools — это расширение для браузера, которое позволяет разработчикам инспектировать структуру компонентов React, отслеживать состояние и props, а также выявлять проблемы в приложении.",
  },
  {
    id: 39,
    question: "Как использовать useSyncExternalStore в React?",
    answer:
      "useSyncExternalStore — это хук, который позволяет подписываться на внешние источники данных и синхронизировать их с состоянием компонента. Это полезно для интеграции с глобальными состояниями или сторонними библиотеками.",
  },
  {
    id: 40,
    question: "Что такое useInsertionEffect в React?",
    answer:
      "useInsertionEffect — это хук, который позволяет выполнять эффекты, которые должны быть вставлены в DOM перед любыми другими изменениями. Это полезно для вставки стилей или скриптов.",
  },
];
const htmlcssCards: FlashCardData[] = [
  {
    id: 1,
    question: "Что такое семантические теги HTML и зачем они нужны?",
    answer:
      "Семантические теги — это теги, которые явно описывают, какой контент внутри них. Например, <header>, <footer>, <article>, <section>. Они помогают поисковым системам и другим разработчикам лучше понимать структуру страницы, а также улучшают доступность для людей с ограниченными возможностями, потому что специальные программы могут читать эти теги и сообщать пользователю, что это, например, заголовок или основное содержимое страницы.",
  },
  {
    id: 2,
    question: "В чем разница между блоковыми и строчными элементами в HTML?",
    answer:
      "Блоковые элементы (например, <div>, <h1>, <p>) занимают всю ширину родительского контейнера и начинают с новой строки. Строчные элементы (например, <span>, <a>, <strong>) занимают только столько места, сколько нужно под их контент, и располагаются в одну строку с другими элементами, если это возможно.",
  },
  {
    id: 3,
    question: "Как работает CSS Flexbox?",
    answer:
      "Flexbox — это модель, которая позволяет создавать гибкие и адаптивные макеты. С Flexbox можно легко выравнивать, распределять и изменять размер элементов внутри контейнера (например, <div>). Ключевые свойства: display: flex, justify-content, align-items, flex-direction. Flexbox особенно удобен для создания горизонтальных и вертикальных центровок и построения адаптивных интерфейсов.",
  },
  {
    id: 4,
    question:
      "Какие преимущества и недостатки CSS Grid по сравнению с Flexbox?",
    answer:
      "Grid лучше подходит для сложных двухмерных макетов (сетка по строкам и столбцам), а Flexbox лучше для одномерных (в строку или в колонку). Grid позволяет четко задавать, сколько у нас строк и столбцов и как они распределяются. Flexbox проще и быстрее настраивается для простых задач выравнивания элементов. Оба метода хорошо работают вместе и часто используются в одном проекте.",
  },
  {
    id: 5,
    question: "Что такое псевдоклассы и псевдоэлементы в CSS?",
    answer:
      "Псевдоклассы (например, :hover, :focus) применяются к элементу в зависимости от его состояния. Псевдоэлементы (например, ::before, ::after) позволяют добавлять стиль к определенной части элемента или создавать виртуальные элементы, которые на самом деле не существуют в HTML. Например, с помощью ::before можно вставить контент перед любым элементом.",
  },
  {
    id: 6,
    question: "Что такое каскад в CSS?",
    answer:
      "Каскад в CSS — это механизм, который определяет, какие стили применяются к элементу, если на него действуют несколько правил. Важными аспектами каскада являются: порядок, в котором правила загружены (последние загруженные стили имеют приоритет), специфичность селекторов (чем конкретнее, тем выше приоритет), и использование ключевых слов вроде !important.",
  },
  {
    id: 7,
    question:
      "Чем отличается абсолютное позиционирование от относительного в CSS?",
    answer:
      "При абсолютном позиционировании элемент удаляется из нормального потока документа и размещается относительно ближайшего родителя с позицией (не static). При относительном позиционировании элемент остается на своем месте, но его можно смещать относительно его начального положения, не нарушая потока.",
  },
  {
    id: 8,
    question: "Как работает z-index?",
    answer:
      "z-index управляет порядком наложения элементов на странице по оси Z (перпендикулярно экрану). Чем больше значение z-index, тем ближе элемент к пользователю. Но z-index работает только для элементов, которые имеют позиционирование (position: absolute, relative, fixed или sticky).",
  },
  {
    id: 9,
    question: "Что такое Box Model в CSS?",
    answer:
      "Box Model описывает, как блоки рассчитываются на странице. Каждый элемент состоит из четырех основных частей: содержимого (content), внутреннего отступа (padding), рамки (border) и внешнего отступа (margin). Важно понимать, что ширина и высота элемента в CSS включают не только содержимое, но и рамки и отступы, если не используется box-sizing: border-box.",
  },
  {
    id: 10,
    question: "Что такое media queries в CSS и зачем они нужны?",
    answer:
      "Media queries позволяют применять стили в зависимости от характеристик устройства, например, ширины экрана, ориентации или разрешения. Это основа для адаптивного веб-дизайна — так можно создать разные стили для мобильных, планшетов и десктопов, обеспечивая лучшую работу на разных устройствах.",
  },
  {
    id: 11,
    question: "Как сделать адаптивные изображения в HTML и CSS?",
    answer:
      "Можно использовать атрибуты srcset и sizes в теге <img>, чтобы указать браузеру разные версии изображения в зависимости от разрешения экрана. Также можно использовать CSS-свойства max-width: 100% и height: auto, чтобы изображение уменьшалось вместе с контейнером.",
  },
  {
    id: 12,
    question: "Какие способы центровки элементов в CSS ты знаешь?",
    answer:
      "Есть несколько способов. Для блоков можно использовать display: flex и свойства justify-content и align-items для горизонтальной и вертикальной центровки. Для inline-элементов можно использовать text-align: center. Еще один способ — применить margin: auto для горизонтальной центровки. В зависимости от задачи могут быть разные подходы.",
  },
  {
    id: 13,
    question: "Что такое CSS-переменные и как их использовать?",
    answer:
      "CSS-переменные (или кастомные свойства) позволяют задавать значения один раз и использовать их во всем документе. Определяются они через --имя в корневом селекторе (например, :root { --main-color: #ff0000; }). Затем их можно использовать как var(--main-color). Это удобно для темизации и повторного использования стилей.",
  },
  {
    id: 14,
    question: "Что такое progressive enhancement и graceful degradation?",
    answer:
      "Progressive enhancement — это подход, при котором базовый функционал сайта должен работать на всех устройствах, а дополнительные функции доступны только на более продвинутых браузерах. Graceful degradation — противоположный подход, при котором сайт разрабатывается для современных браузеров, но частично работает на старых.",
  },
  {
    id: 15,
    question:
      "Как использовать иконки с помощью шрифтов (например, Font Awesome)?",
    answer:
      "Иконки через шрифты работают так же, как и текстовые символы. Подключаем шрифт (например, Font Awesome) через CDN или локальный файл и используем нужные иконки через классы, например, <i class='fas fa-home'></i>. Такие иконки легко масштабируются и стилизуются через CSS.",
  },
  {
    id: 16,
    question: "Что такое clearfix и зачем он нужен?",
    answer:
      "Clearfix — это CSS-хак, который помогает правильно отображать контейнеры, если в них находятся плавающие элементы (float). Обычно применяется к родительскому элементу, чтобы он корректно 'обтекал' float-элементы. Стандартный пример: .clearfix::after { content: ''; display: block; clear: both; }.",
  },
  {
    id: 17,
    question: "Какие значения display ты знаешь и как они влияют на элементы?",
    answer:
      "Некоторые значения display: block — элемент занимает всю ширину; inline — элемент занимает только пространство своего контента; inline-block — можно задавать размеры, но элемент находится на одной строке с другими; flex — создает flex-контейнер для гибкого макета; grid — создает grid-контейнер; none — элемент не отображается.",
  },
  {
    id: 18,
    question:
      "Как работает CSS-анимация и какие ключевые моменты нужно учесть?",
    answer:
      "Анимации в CSS задаются с помощью ключевых кадров (@keyframes) и свойства animation. Например, можно задать движение объекта с одной точки в другую. Важно учитывать плавность (ease-in, ease-out), длительность и частоту кадров, чтобы анимация выглядела естественно и не нагружала браузер.",
  },
  {
    id: 19,
    question: "Как работают таблицы в HTML и когда их стоит использовать?",
    answer:
      "Таблицы создаются с помощью <table>, <tr>, <td> и <th> для отображения табличных данных. Таблицы полезны для данных, которые имеют строгую структуру (например, расписания или финансовые данные), но не подходят для создания макетов страниц, так как сложно сделать адаптивный дизайн.",
  },
  {
    id: 20,
    question: "Что такое inline и block context в HTML?",
    answer:
      "Block context — это когда элемент ведет себя как блок, занимает всю ширину, не может быть расположен рядом с другими элементами в строке (например, <div>). Inline context — это когда элемент ведет себя как строчный элемент, можно располагать несколько inline-элементов в одной строке (например, <span>).",
  },
  {
    id: 21,
    question: "Как сделать стилизованные формы в HTML и CSS?",
    answer:
      "Стилизация форм требует использования CSS для изменения внешнего вида элементов, таких как <input>, <textarea>, <select>. Можно изменить их ширину, цвет границ, фокусные состояния и добавить эффекты наведения. Обычно для создания красивых форм используют такие CSS-свойства, как padding, margin, border, а также псевдоклассы вроде :focus и :hover.",
  },
  {
    id: 22,
    question: "Как улучшить производительность CSS на сайте?",
    answer:
      "Во-первых, минимизировать использование сложных селекторов (например, избегать вложенности > 3 уровней). Во-вторых, уменьшить количество загружаемых CSS-файлов, используя один файл для всего сайта. Также можно применять критический CSS для рендера ключевых стилей перед полной загрузкой страницы. И, конечно, важно минимизировать и сжимать файлы CSS.",
  },
  {
    id: 23,
    question: "Что такое фреймворки CSS и зачем они нужны?",
    answer:
      "CSS-фреймворки, такие как Bootstrap или Tailwind, содержат готовые стили и компоненты для ускорения разработки. Они помогают быстро верстать интерфейсы, обеспечивая адаптивный дизайн и поддержку кроссбраузерности. Это полезно, чтобы не тратить время на написание базовых стилей с нуля.",
  },
  {
    id: 24,
    question:
      "Что такое responsive дизайн и какие методы для этого существуют?",
    answer:
      "Responsive дизайн — это подход, при котором сайт выглядит хорошо на всех устройствах: от мобильных до больших мониторов. Основные методы: использование гибких сеток (flex, grid), адаптивных изображений, медиа-запросов (media queries) и относительных единиц измерения (%, rem, vw).",
  },
  {
    id: 25,
    question: "Чем отличаются relative и absolute единицы измерения в CSS?",
    answer:
      "Relative единицы, такие как %, em, rem, зависят от других значений на странице (например, от родительского элемента или базового размера шрифта). Absolute единицы, такие как px, cm, in, фиксированы и не зависят от контекста страницы.",
  },
  {
    id: 26,
    question: "Что такое препроцессоры CSS и зачем их использовать?",
    answer:
      "Препроцессоры, такие как Sass или Less, расширяют возможности стандартного CSS. Они добавляют переменные, вложенность, миксины, что упрощает управление стилями и делает код более читаемым и модульным. Препроцессоры компилируются в обычный CSS для использования на веб-сайте.",
  },
  {
    id: 27,
    question: "Что такое позиционирование sticky и в чем его отличие от fixed?",
    answer:
      "Sticky позиционирование позволяет элементу оставаться на месте, когда он прокручивается до определенной точки, а затем фиксироваться на экране. Fixed позиционирование делает элемент всегда зафиксированным относительно окна браузера, вне зависимости от прокрутки.",
  },
  {
    id: 28,
    question:
      "Что такое браузерные префиксы в CSS и когда их нужно использовать?",
    answer:
      "Браузерные префиксы (например, -webkit-, -moz-, -o-) используются для поддержки экспериментальных CSS-свойств в разных браузерах. Сегодня многие свойства уже стабилизировались и префиксы не всегда нужны, но иногда их всё ещё применяют для поддержки старых версий браузеров.",
  },
  {
    id: 29,
    question:
      "Какие проблемы могут возникнуть при работе с float и как их избегать?",
    answer:
      "Float часто приводит к проблемам с 'коллапсом' родительских контейнеров, если внутри float-элементы. Это решается применением clearfix, также float может нарушать поток документа, если не контролировать, как элементы обтекают друг друга. Flexbox или Grid могут быть лучшей альтернативой.",
  },
  {
    id: 30,
    question: "Как работает свойство object-fit и для чего оно используется?",
    answer:
      "Object-fit используется для контроля, как контент (например, изображение) вписывается в контейнер. Например, значение cover заставит изображение заполнить контейнер, сохраняя пропорции, но обрезая часть изображения. Это полезно для создания адаптивных изображений и видео.",
  },
];
const jsCards: FlashCardData[] = [
  {
    id: 1,
    question: "Что такое замыкание (closure) в JavaScript?",
    answer:
      "Замыкание – это функция, которая 'запоминает' свою область видимости, даже если она была вызвана вне этой области. Например, если внутри функции создаешь другую функцию, то внутренняя будет иметь доступ к переменным внешней функции, даже после завершения её выполнения.",
  },
  {
    id: 2,
    question: "В чем разница между 'var', 'let' и 'const'?",
    answer:
      "'var' устаревший способ объявления переменных, они имеют функциональную область видимости. 'let' и 'const' – более современные, с блочной областью видимости. Разница между 'let' и 'const' в том, что 'const' не позволяет изменять значение после присвоения, а 'let' – позволяет.",
  },
  {
    id: 3,
    question: "Что такое 'hoisting' в JavaScript?",
    answer:
      "'Hoisting' – это процесс, при котором объявления переменных и функций поднимаются наверх своей области видимости. Например, если ты объявил функцию внизу, а вызвал её вверху, она все равно выполнится. Но с переменными 'var' это работает частично: только объявление поднимается, но не присвоение значения.",
  },
  {
    id: 4,
    question: "Как работает асинхронность в JavaScript?",
    answer:
      "JavaScript работает по принципу однопоточного выполнения кода. Но асинхронные операции, такие как запросы к серверу или таймеры, выполняются в фоновом режиме и используют 'событийный цикл' (event loop), чтобы обработать результат, когда основной поток будет свободен.",
  },
  {
    id: 5,
    question: "Что такое 'Promise' и как он работает?",
    answer:
      "'Promise' – это объект, который представляет результат асинхронной операции. Он может находиться в одном из трёх состояний: ожидается (pending), выполнен (resolved) или отклонен (rejected). Ты можешь использовать '.then()' для обработки успешного результата и '.catch()' для обработки ошибок.",
  },
  {
    id: 6,
    question: "Как работает 'async/await'?",
    answer:
      "'async/await' – это более удобный способ работы с промисами. 'async' помечает функцию как асинхронную, а 'await' заставляет JavaScript дождаться завершения промиса перед выполнением следующей строки кода, что делает код более читаемым и последовательным.",
  },
  {
    id: 7,
    question: "Что такое 'event loop' в JavaScript?",
    answer:
      "'Event loop' – это механизм, который позволяет JavaScript выполнять асинхронные операции. Он следит за основной очередью задач и очередью коллбэков (например, асинхронные операции), и когда основной стек становится пустым, он начинает обрабатывать задачи из очереди коллбэков.",
  },
  {
    id: 8,
    question: "Что такое 'callback' функция?",
    answer:
      "'Callback' – это функция, переданная в другую функцию как аргумент и вызываемая внутри этой функции. Она часто используется для обработки асинхронных операций, когда ты хочешь, чтобы функция выполнилась после завершения какой-то другой.",
  },
  {
    id: 9,
    question: "Как работает 'this' в JavaScript?",
    answer:
      "'this' – это ключевое слово, которое ссылается на объект, в контексте которого вызвана функция. В глобальной области видимости 'this' будет ссылаться на глобальный объект (в браузере это 'window'). В методах объектов 'this' будет ссылаться на сам объект, к которому принадлежит метод.",
  },
  {
    id: 10,
    question: "Как работает деструктуризация объектов и массивов?",
    answer:
      "Деструктуризация – это способ извлечения значений из объектов или массивов в переменные. Например, из объекта можно извлечь нужные свойства, используя синтаксис: 'const {name, age} = user'. С массивами аналогично: 'const [first, second] = arr'.",
  },
  {
    id: 11,
    question: "Что такое 'spread' и 'rest' операторы?",
    answer:
      "'Spread' (...) используется для 'распаковки' элементов массива или объекта в новый массив/объект или в качестве аргументов функции. 'Rest' (...) используется для 'сбора' аргументов функции или элементов массива в одну переменную.",
  },
  {
    id: 12,
    question: "Чем отличается 'map' от 'forEach'?",
    answer:
      "'forEach' выполняет функцию для каждого элемента массива, но ничего не возвращает. 'map' делает то же самое, но возвращает новый массив с результатами выполнения функции для каждого элемента.",
  },
  {
    id: 13,
    question: "Что такое 'pure function' (чистая функция)?",
    answer:
      "Чистая функция – это функция, которая при одинаковых входных данных всегда возвращает одинаковый результат и не имеет побочных эффектов (не изменяет внешние данные или состояние). Такие функции легко тестировать и предсказуемы.",
  },
  {
    id: 14,
    question: "Что такое 'debounce' и 'throttle'?",
    answer:
      "'Debounce' откладывает выполнение функции до тех пор, пока не прекратится серия вызовов (например, при вводе текста). 'Throttle' ограничивает количество вызовов функции до одного за определённый интервал времени (например, при прокрутке страницы).",
  },
  {
    id: 15,
    question: "Что такое 'strict mode' в JavaScript и зачем он нужен?",
    answer:
      "'Strict mode' – это режим, который позволяет избежать некоторых 'тихих' ошибок, делая их явными, а также запрещает использование определённых небезопасных возможностей. Включается добавлением строки 'use strict'.",
  },
  {
    id: 16,
    question:
      "Как работают стрелочные функции (arrow functions) и чем они отличаются от обычных?",
    answer:
      "Стрелочные функции имеют более короткий синтаксис и не имеют своего контекста 'this' – они захватывают 'this' из окружающего контекста. Это удобно при работе с методами объектов или при передаче функций-обработчиков событий.",
  },
  {
    id: 17,
    question: "Что такое IIFE (Immediately Invoked Function Expression)?",
    answer:
      "IIFE – это функция, которая выполняется сразу после того, как была определена. Это делается, чтобы создать изолированную область видимости и избежать конфликтов с другими переменными или функциями в глобальной области.",
  },
  {
    id: 18,
    question: "В чем разница между '==', '==='?",
    answer:
      "'==' сравнивает значения, выполняя приведение типов, а '===' проверяет и значение, и тип, без приведения. Лучше использовать '===', чтобы избежать неожиданных ошибок при сравнении значений разных типов.",
  },
  {
    id: 19,
    question: "Что такое 'prototype' и как работает наследование в JavaScript?",
    answer:
      "Каждый объект в JavaScript имеет свойство 'prototype', которое ссылается на другой объект. Это позволяет одному объекту 'унаследовать' свойства и методы другого объекта. Это основа прототипного наследования в JavaScript.",
  },
  {
    id: 20,
    question: "Что такое 'event delegation'?",
    answer:
      "'Event delegation' – это техника, при которой ты вешаешь один обработчик события на родительский элемент, вместо того, чтобы вешать их на каждый дочерний элемент. Это работает благодаря всплытию событий, когда событие сначала происходит на целевом элементе, а потом поднимается вверх по DOM.",
  },
  {
    id: 21,
    question:
      "Как работает всплытие (event bubbling) и погружение событий (event capturing)?",
    answer:
      "Всплытие – это когда событие, произошедшее на элементе, поднимается вверх по дереву DOM до самого верхнего элемента. Погружение – это когда событие сначала идет сверху вниз. Всплытие чаще используется, но иногда можно управлять стадией захвата.",
  },
  {
    id: 22,
    question: "Что такое 'fetch' и как его использовать?",
    answer:
      "'fetch' – это современный способ делать HTTP-запросы в JavaScript. Он возвращает промис, который можно обрабатывать с помощью 'then' и 'catch'. Например: 'fetch(url).then(response => response.json()).then(data => console.log(data))'.",
  },
  {
    id: 23,
    question: "Что такое 'JSON' и как его использовать в JavaScript?",
    answer:
      "JSON (JavaScript Object Notation) – это формат для передачи данных между сервером и клиентом. В JavaScript можно использовать 'JSON.stringify()' для преобразования объекта в JSON и 'JSON.parse()' для преобразования строки JSON в объект.",
  },
  {
    id: 24,
    question: "Как работает 'localStorage' и 'sessionStorage'?",
    answer:
      "'localStorage' и 'sessionStorage' позволяют сохранять данные на стороне клиента. 'localStorage' сохраняет данные между сессиями браузера, а 'sessionStorage' удаляет их при закрытии вкладки. Оба сохраняют данные в формате ключ-значение.",
  },
  {
    id: 25,
    question:
      "Что такое модуль в JavaScript и как его импортировать/экспортировать?",
    answer:
      "Модуль – это отдельный файл, который экспортирует определённые функции, объекты или переменные, чтобы они могли быть импортированы и использованы в других файлах. Для экспорта используется 'export', для импорта – 'import'. Например: 'import { myFunction } from './module.js''.",
  },
  {
    id: 26,
    question: "Как работают классы в JavaScript?",
    answer:
      "Классы – это синтаксический сахар над прототипами. Они позволяют создавать объекты с наследованием и методами. С помощью 'class' и 'constructor' можно определять шаблоны для объектов. 'extends' используется для наследования.",
  },
  {
    id: 27,
    question: "Что такое 'WeakMap' и 'WeakSet'?",
    answer:
      "'WeakMap' и 'WeakSet' – это специальные коллекции, которые позволяют хранить объекты без предотвращения их сборки мусора. Это полезно, когда нужно хранить ссылки на объекты, но не мешать их удалению, если они больше не нужны.",
  },
  {
    id: 28,
    question: "Что такое 'Symbol' в JavaScript?",
    answer:
      "'Symbol' – это уникальный и неизменяемый тип данных, который может использоваться как ключ для свойств объекта. Это полезно для создания уникальных идентификаторов, которые не будут конфликтовать с другими свойствами объекта.",
  },
  {
    id: 29,
    question: "Как работают генераторы (generator functions) в JavaScript?",
    answer:
      "Генераторы – это функции, которые могут приостанавливать своё выполнение и возобновлять его позже. Они возвращают объект-итератор, а выполнение приостанавливается с помощью ключевого слова 'yield'. Это полезно для работы с последовательностями данных.",
  },
  {
    id: 30,
    question: "Что такое 'deep copy' и 'shallow copy' в JavaScript?",
    answer:
      "Shallow copy (поверхностная копия) копирует только верхний уровень объекта, а ссылки на вложенные объекты остаются прежними. Deep copy (глубокая копия) создает полную копию объекта, включая все вложенные объекты. Для глубокого копирования можно использовать 'structuredClone' или библиотеки, такие как 'lodash'.",
  },
];
const reactCards: FlashCardData[] = [
  {
    id: 1,
    question: "Что такое React и почему его используют?",
    answer:
      "React — это библиотека JavaScript для создания пользовательских интерфейсов, разработанная Facebook. Его используют, потому что он делает создание динамичных и интерактивных приложений проще благодаря концепции компонентов, виртуальному DOM и быстрому обновлению UI.",
  },
  {
    id: 2,
    question: "Что такое компоненты в React?",
    answer:
      "Компоненты — это строительные блоки интерфейса в React. Это небольшие, изолированные части кода, которые отвечают за рендеринг части UI. Компоненты могут быть функциональными или классовыми.",
  },
  {
    id: 3,
    question: "Чем функциональные компоненты отличаются от классовых?",
    answer:
      "Функциональные компоненты — это просто функции, которые возвращают JSX. Классовые компоненты используют классы JavaScript и обладают собственным состоянием и методами жизненного цикла, но современные React-приложения все чаще используют функциональные компоненты с хуками, поскольку они проще и легче читаются.",
  },
  {
    id: 4,
    question: "Что такое JSX?",
    answer:
      "JSX — это расширение синтаксиса JavaScript, которое позволяет писать разметку в коде. Это похоже на HTML, но внутри JavaScript. React использует JSX для описания UI-компонентов, чтобы код был более наглядным.",
  },
  {
    id: 5,
    question: "Как работает виртуальный DOM в React?",
    answer:
      "Виртуальный DOM — это легкая копия реального DOM. Когда меняется состояние компонента, React обновляет только измененные части виртуального DOM, а затем минимально обновляет реальный DOM, чтобы повысить производительность.",
  },
  {
    id: 6,
    question: "Что такое хук useState?",
    answer:
      "useState — это хук, который позволяет добавлять состояние в функциональные компоненты. Он возвращает массив с двумя элементами: текущее значение состояния и функцию для его обновления.",
  },
  {
    id: 7,
    question: "Что такое хук useEffect?",
    answer:
      "useEffect — это хук, который позволяет управлять побочными эффектами в функциональных компонентах, например, запросами к API или подписками. Он работает аналогично методам жизненного цикла в классовых компонентах, таким как componentDidMount и componentDidUpdate.",
  },
  {
    id: 8,
    question: "Когда нужно использовать useMemo и useCallback?",
    answer:
      "useMemo используется для мемоизации значений, чтобы избегать повторных вычислений, когда не нужно. useCallback — для мемоизации функций. Это полезно, когда нужно оптимизировать рендеринг и передавать неизменяемые функции или значения в дочерние компоненты.",
  },
  {
    id: 9,
    question: "Как работают контексты (Context API) в React?",
    answer:
      "Context API используется для передачи данных через дерево компонентов без необходимости явно передавать пропсы на каждом уровне. Это удобно для глобальных данных, таких как темы, язык или текущий пользователь.",
  },
  {
    id: 10,
    question: "Что такое React Router и зачем он нужен?",
    answer:
      "React Router — это библиотека для маршрутизации в React-приложениях. Он позволяет создавать одностраничные приложения (SPA), где пользователи могут переключаться между различными страницами без перезагрузки.",
  },
  {
    id: 11,
    question: "Как работает динамическая маршрутизация в React Router?",
    answer:
      "Динамическая маршрутизация позволяет создавать пути с переменными, например '/users/:id'. Эти переменные можно извлечь с помощью хуков, таких как useParams, и использовать для отображения динамического контента.",
  },
  {
    id: 12,
    question: "Что такое lazy loading компонентов в React?",
    answer:
      "Lazy loading — это отложенная загрузка компонентов. Вместо того чтобы загружать все сразу, React загружает компоненты только тогда, когда они нужны. Для этого используется функция React.lazy и компонент Suspense.",
  },
  {
    id: 13,
    question: "Что такое error boundaries и для чего они нужны?",
    answer:
      "Error boundaries — это компоненты, которые ловят ошибки JavaScript в дочерних компонентах во время рендеринга, в методах жизненного цикла или в конструкторах. Они позволяют отображать резервный UI вместо сломанного приложения.",
  },
  {
    id: 14,
    question: "Чем отличаются управляемые и неуправляемые компоненты?",
    answer:
      "Управляемые компоненты — это компоненты, где состояние формы хранится в React, а неуправляемые — те, где состояние формы хранится в DOM (через refs). Управляемые компоненты дают больше контроля над состоянием.",
  },
  {
    id: 15,
    question: "Как использовать Refs в React?",
    answer:
      "Refs используются для доступа к DOM-элементам или компонентам напрямую. Они не участвуют в рендеринге и позволяют, например, фокусироваться на элементе ввода или управлять анимациями.",
  },
  {
    id: 16,
    question: "Что такое Redux и зачем он нужен в React?",
    answer:
      "Redux — это библиотека для управления состоянием в React-приложениях. Она помогает управлять состоянием, особенно в больших приложениях, когда состояние нужно передавать через множество компонентов.",
  },
  {
    id: 17,
    question: "Что такое хранилище (store) в Redux?",
    answer:
      "Хранилище (store) — это объект, который хранит все состояние приложения в Redux. Компоненты могут подписываться на изменения в store и получать обновленные данные через селекторы.",
  },
  {
    id: 18,
    question: "Что такое action и reducer в Redux?",
    answer:
      "Action — это объект, который описывает, что произошло, обычно с типом события и полезной нагрузкой. Reducer — это чистая функция, которая принимает текущее состояние и action и возвращает новое состояние.",
  },
  {
    id: 19,
    question: "Что такое хук useReducer и когда его использовать?",
    answer:
      "useReducer — это хук, который позволяет управлять состоянием сложных компонентов через reducer-функцию. Это хороший выбор, когда компонент имеет много состояний, или когда логика обновления состояния сложная.",
  },
  {
    id: 20,
    question: "Как подключить Redux к React через React-Redux?",
    answer:
      "React-Redux предоставляет хук useSelector для извлечения данных из store и хук useDispatch для отправки actions. Эти хуки позволяют взаимодействовать с Redux-состоянием внутри компонентов.",
  },
  {
    id: 21,
    question: "Что такое middleware в Redux?",
    answer:
      "Middleware — это функции, которые находятся между dispatch и reducer. Они позволяют обрабатывать асинхронные действия, например, запросы к API, прежде чем передать их в reducer.",
  },
  {
    id: 22,
    question: "Что такое Redux Thunk?",
    answer:
      "Redux Thunk — это middleware, который позволяет писать асинхронные действия (action creators) в Redux. Это нужно для того, чтобы отправлять несколько действий последовательно или после завершения асинхронных операций, таких как запросы к серверу.",
  },
  {
    id: 23,
    question: "Что такое React Query и как он помогает с данными?",
    answer:
      "React Query — это библиотека для управления серверными данными в React. Она упрощает запросы данных, кэширование, рефетчинг и синхронизацию состояния с сервером, позволяя избежать ручного управления состоянием запросов.",
  },
  {
    id: 24,
    question: "Что такое Next.js и в чем его преимущества?",
    answer:
      "Next.js — это фреймворк поверх React, который добавляет серверный рендеринг, статическую генерацию и маршрутизацию из коробки. Он помогает улучшить SEO и производительность за счет гибридной рендеринговой модели.",
  },
  {
    id: 25,
    question:
      "Что такое server-side rendering (SSR) и как он работает в Next.js?",
    answer:
      "SSR — это рендеринг страницы на сервере перед отправкой её пользователю. В Next.js это достигается с помощью функций getServerSideProps, которые получают данные для рендеринга страницы на сервере.",
  },
  {
    id: 26,
    question: "Что такое static site generation (SSG) в Next.js?",
    answer:
      "SSG — это статическая генерация страниц на этапе билда. Страницы рендерятся один раз и кэшируются для каждого пользователя. В Next.js для этого используется функция getStaticProps.",
  },
  {
    id: 27,
    question: "Как использовать хуки React вместе с TypeScript?",
    answer:
      "Чтобы использовать хуки с TypeScript, нужно типизировать параметры и возвращаемые значения. Например, для useState указываем тип состояния, а для useReducer — типы action и состояния в reducer-функции.",
  },
  {
    id: 28,
    question: "Как работает Suspense в React?",
    answer:
      "Suspense используется для отложенного рендеринга и показа резервного контента, пока данные загружаются. Это особенно полезно с React.lazy для динамической подгрузки компонентов.",
  },
  {
    id: 29,
    question: "Что такое React.memo и зачем его использовать?",
    answer:
      "React.memo — это HOC (higher-order component), который мемоизирует компонент и предотвращает его повторный рендеринг, если его пропсы не изменились. Это помогает улучшить производительность.",
  },
  {
    id: 30,
    question: "Чем отличаются useEffect и useLayoutEffect?",
    answer:
      "useEffect выполняется после рендеринга, а useLayoutEffect — перед тем, как браузер нарисует изменения на экране. useLayoutEffect можно использовать для измерения DOM-элементов или выполнения синхронных эффектов.",
  },
];
const tsCards: FlashCardData[] = [
  {
    id: 1,
    question: "Что такое TypeScript и зачем он нужен в React-проектах?",
    answer:
      "TypeScript — это надстройка над JavaScript, которая добавляет строгую типизацию. В React-проектах он помогает ловить ошибки на этапе разработки, повышает читаемость кода и упрощает работу с большими командами.",
  },
  {
    id: 2,
    question:
      "Чем интерфейсы (interface) отличаются от типов (type) в TypeScript?",
    answer:
      "Основное различие — интерфейсы обычно используются для описания объектов, а типы более универсальны. Также интерфейсы можно расширять, а типы объединять с помощью оператора '&'.",
  },
  {
    id: 3,
    question: "Как описать тип для props в React-компоненте?",
    answer:
      "Ты можешь создать интерфейс или тип для пропсов, а затем передать его через <ComponentProps> в компонент. Например: `interface MyProps { title: string; } function MyComponent(props: MyProps) {...}`.",
  },
  {
    id: 4,
    question:
      "Что такое Generics (обобщенные типы) в TypeScript и как они применяются в React?",
    answer:
      "Generics — это способ работы с типами, которые могут быть динамическими. Например, если ты пишешь компонент, который принимает массив любых данных, ты можешь использовать дженерики для большей гибкости: `function List<T>(items: T[]) {...}`.",
  },
  {
    id: 5,
    question: "Как работают перечисления (enum) в TypeScript?",
    answer:
      "Enum — это способ создать набор именованных значений. Например: `enum Direction { Up, Down, Left, Right }`. Это удобно для передачи ограниченного числа вариантов, например, состояний или направлений.",
  },
  {
    id: 6,
    question: "Как использовать типы для событий (event) в React?",
    answer:
      "Для событий в React есть встроенные типы, например, `React.MouseEvent` или `React.ChangeEvent<HTMLInputElement>`. Это помогает типизировать обработчики событий, чтобы избежать ошибок.",
  },
  {
    id: 7,
    question: "Как типизировать state и setState в функциональных компонентах?",
    answer:
      "Для этого можно использовать дженерики в `useState`. Например: `const [count, setCount] = useState<number>(0);`. Это гарантирует, что state будет числом, а не чем-то другим.",
  },
  {
    id: 8,
    question: "Что такое тип `any` и почему его стоит избегать?",
    answer:
      "`any` отключает проверку типов, что может привести к ошибкам. Его стоит избегать, так как он убирает всю пользу TypeScript. Лучше использовать более точные типы или хотя бы `unknown`.",
  },
  {
    id: 9,
    question: "В чем разница между `unknown` и `any`?",
    answer:
      "`unknown` требует, чтобы перед использованием ты явно проверил тип данных, тогда как `any` позволяет использовать значение без проверки. `unknown` безопаснее, потому что заставляет обрабатывать типы осторожнее.",
  },
  {
    id: 10,
    question:
      "Как создать обязательные и необязательные пропсы в React-компоненте?",
    answer:
      "В интерфейсе для пропсов ты можешь сделать некоторые поля необязательными, добавив знак вопроса. Например: `interface Props { name: string; age?: number }`. Теперь `age` можно не передавать.",
  },
  {
    id: 11,
    question: "Как работает типизация `defaultProps` в TypeScript?",
    answer:
      "`defaultProps` используется для задания значений по умолчанию для пропсов. В TypeScript важно, чтобы типы этих значений соответствовали объявленным пропсам. Например: `MyComponent.defaultProps = { age: 18 }`.",
  },
  {
    id: 12,
    question: "Что такое `type assertions` и когда они нужны?",
    answer:
      "`Type assertions` (утверждения типов) позволяют разработчику явно указать TypeScript, что он знает тип лучше. Это делается с помощью оператора `as`. Например: `let str = value as string;`. Но важно использовать их осторожно!",
  },
  {
    id: 13,
    question: "Как типизировать `refs` в React?",
    answer:
      "Для этого используют `React.RefObject<T>`. Например: `const inputRef = useRef<HTMLInputElement>(null);`. Это типизирует `ref` как ссылку на элемент input и помогает избежать ошибок.",
  },
  {
    id: 14,
    question: "Что такое `Partial<T>` и как его использовать?",
    answer:
      "`Partial<T>` делает все свойства объекта необязательными. Например, если у тебя есть тип `interface User { name: string; age: number; }`, то `Partial<User>` создаст тип с необязательными полями.",
  },
  {
    id: 15,
    question: "Как работает `Pick<T, K>`?",
    answer:
      "`Pick<T, K>` позволяет выбрать только нужные поля из объекта. Например, `Pick<User, 'name'>` создаст новый тип с полем только `name`, игнорируя другие поля типа.",
  },
  {
    id: 16,
    question: "Что такое `Record<K, T>`?",
    answer:
      "`Record<K, T>` создает объект, где ключи — это тип `K`, а значения — тип `T`. Например: `Record<string, number>` создаст объект с текстовыми ключами и числовыми значениями.",
  },
  {
    id: 17,
    question: "Как работают условные типы (conditional types) в TypeScript?",
    answer:
      "Условные типы позволяют создавать динамические типы, основанные на проверках. Например: `T extends U ? X : Y` возвращает `X`, если тип `T` является подтипом `U`, иначе — `Y`.",
  },
  {
    id: 18,
    question: "Зачем использовать `Readonly<T>`?",
    answer:
      "`Readonly<T>` делает все поля объекта неизменяемыми. Это полезно, когда ты хочешь защитить объект от случайных изменений.",
  },
  {
    id: 19,
    question: "Как типизировать контекст (Context API) в React с TypeScript?",
    answer:
      "Сначала создаешь интерфейс для типа данных, который будет храниться в контексте, затем используешь этот интерфейс для типизации `createContext` и `useContext`. Например: `const MyContext = createContext<MyType | null>(null);`.",
  },
  {
    id: 20,
    question: "Как типизировать компоненты высшего порядка (HOC) в React?",
    answer:
      "Для этого можно использовать дженерики и передать типы пропсов и состояния в функцию HOC. Например: `function withLoading<T>(Component: React.ComponentType<T>) { return function (props: T) {...} }`.",
  },
  {
    id: 21,
    question: "Как работают пользовательские хуки с TypeScript?",
    answer:
      "Пользовательские хуки типизируются так же, как обычные функции, с учетом возвращаемых значений и аргументов. Например: `function useCustomHook<T>(data: T): [T, () => void] {...}`.",
  },
  {
    id: 22,
    question: "Что такое `Intersection Types` и как их использовать?",
    answer:
      "Intersection Types (`&`) позволяют объединять несколько типов. Например: `type Combined = TypeA & TypeB`. Это полезно, когда объект должен содержать свойства из обоих типов.",
  },
  {
    id: 23,
    question: "Как работают `Union Types` в TypeScript?",
    answer:
      "`Union Types` (`|`) позволяют переменной быть одним из нескольких типов. Например: `let value: string | number`. Это значит, что переменная может быть как строкой, так и числом.",
  },
  {
    id: 24,
    question: "Что такое `Discriminated Unions` и зачем они нужны?",
    answer:
      "Это шаблон, который используется для безопасной работы с union типами. Каждый тип в объединении имеет общее поле, которое позволяет определить, какой именно тип используется. Например, `type Shape = { kind: 'circle', radius: number } | { kind: 'square', size: number }`.",
  },
  {
    id: 25,
    question: "Как типизировать асинхронные функции и `Promise` в TypeScript?",
    answer:
      "Асинхронные функции возвращают `Promise<T>`, где `T` — это тип значения, которое будет возвращено. Например: `async function fetchData(): Promise<string> { return 'data'; }`.",
  },
  {
    id: 26,
    question: "Что такое `never` и когда он используется?",
    answer:
      "`never` указывает на тип, который никогда не будет значением. Например, это может быть функция, которая всегда выбрасывает ошибку или зацикливается. Тип `never` помогает TypeScript понять, что до этого кода выполнение программы не дойдет.",
  },
  {
    id: 27,
    question: "Как использовать `keyof` в TypeScript?",
    answer:
      "`keyof` возвращает ключи объекта как строковые литералы. Например: `type UserKeys = keyof User` вернет `'name' | 'age'` для объекта `User`. Это полезно, когда нужно работать с динамическими ключами.",
  },
  {
    id: 28,
    question: "Что такое маппированные типы (Mapped Types)?",
    answer:
      "Маппированные типы позволяют создавать новые типы, изменяя существующие. Например, `type ReadonlyUser = { [P in keyof User]: Readonly<User[P]> }` сделает все поля объекта `User` неизменяемыми.",
  },
  {
    id: 29,
    question: "Как работает оператор `?` при доступе к свойствам?",
    answer:
      "Это оператор optional chaining. Он позволяет безопасно обращаться к вложенным свойствам объекта, даже если одно из промежуточных значений может быть `null` или `undefined`. Например: `user?.address?.city`.",
  },
  {
    id: 30,
    question: "Что такое strict mode в TypeScript и зачем его включать?",
    answer:
      "`strict mode` включает набор строгих проверок типов, таких как обязательная инициализация переменных, строгие проверки null и undefined. Включение `strict` помогает находить больше ошибок на этапе компиляции.",
  },
];

export default function FlashCardApp() {
  const [flashcards, setFlashcards] = useState<FlashCardData[]>(flashcardsDef);
  const [currentCardIndex, setCurrentCardIndex] = useState(0);
  const [direction, setDirection] = useState(0);
  const [answeredCorrectly, setAnsweredCorrectly] = useState<boolean[]>(
    new Array(flashcards.length).fill(false),
  );

  const handleNext = () => {
    setCurrentCardIndex((prevIndex) => (prevIndex + 1) % flashcards.length);
    setDirection(1);
  };

  const handlePrevious = () => {
    setCurrentCardIndex(
      (prevIndex) => (prevIndex - 1 + flashcards.length) % flashcards.length,
    );
    setDirection(-1);
  };

  const handleAnswer = (isCorrect: boolean) => {
    setAnsweredCorrectly((prev) => {
      const newAnswers = [...prev];
      newAnswers[currentCardIndex] = isCorrect;
      return newAnswers;
    });
    handleNext();
  };

  const handleSwapCards = (category: CategoryCards) => {
    setCurrentCardIndex(0);

    switch (category) {
      case "default":
        setFlashcards(flashcardsDef);
        break;
      case "htmlcss":
        setFlashcards(htmlcssCards);
        break;
      case "js":
        setFlashcards(jsCards);
        break;
      case "react":
        setFlashcards(reactCards);
        break;
      case "ts":
        setFlashcards(tsCards);
        break;
    }
  };

  const variants = {
    enter: (direction: number) => {
      return {
        x: direction > 0 ? 100 : -100,
        opacity: 0,
      };
    },
    center: {
      x: 0,
      opacity: 1,
    },
    exit: (direction: number) => {
      return {
        x: direction < 0 ? 100 : -100,
        opacity: 0,
      };
    },
  };

  return (
    <>
      <div className="flex gap-2">
        <button
          onClick={() => handleSwapCards("default")}
          className="bg-slate-300 p-3"
        >
          default
        </button>
        <button
          onClick={() => handleSwapCards("htmlcss")}
          className="bg-slate-300 p-3"
        >
          html & css
        </button>
        <button
          onClick={() => handleSwapCards("js")}
          className="bg-slate-300 p-3"
        >
          JavaScript
        </button>
        <button
          onClick={() => handleSwapCards("react")}
          className="bg-slate-300 p-3"
        >
          React
        </button>
        <button
          onClick={() => handleSwapCards("ts")}
          className="bg-slate-300 p-3"
        >
          TypeScript
        </button>
      </div>
      <div className="flex min-h-screen flex-col items-center justify-center bg-gray-100 p-4">
        <AnimatePresence mode="wait" custom={direction}>
          <motion.div
            key={currentCardIndex}
            custom={direction}
            variants={variants}
            initial="enter"
            animate="center"
            exit="exit"
            transition={{ duration: 0.3 }}
          >
            <FlashCard card={flashcards[currentCardIndex]} />
          </motion.div>
        </AnimatePresence>
        <Controls
          onNext={handleNext}
          onPrevious={handlePrevious}
          onCorrect={() => handleAnswer(true)}
          onIncorrect={() => handleAnswer(false)}
        />
        <div className="mt-4 text-lg font-semibold">
          {currentCardIndex + 1} / {flashcards.length}
        </div>
      </div>
    </>
  );
}
